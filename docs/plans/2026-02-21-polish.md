# TextTools v0.3.0 Polish Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:subagent-driven-development to implement this plan task-by-task.

**Goal:** Fix seven polish items identified from qt-pilot testing and DESIGN.md spec review: wrong default tab, missing keyboard shortcuts, misleading encoding label, stubbed conversion button, no cursor position in status bar, stubbed Save As, and no config persistence.

**Architecture:** All changes are in the View layer (`main_window.py`), Service layer (`file_service.py`), and ViewModel layer (`main_viewmodel.py`). No new files, no new services. One `.ui` file change. MVVM layer rules strictly enforced throughout.

**Tech Stack:** Python 3.14, PySide6 6.8+, pytest, pytest-qt, QSettings (platform-native INI on Linux)

---

## Context for implementer

Read these files before starting any task:
- `src/views/main_window.py` — the View (signal wiring, slot handlers)
- `src/viewmodels/main_viewmodel.py` — the ViewModel (signals, business logic)
- `src/services/file_service.py` — file I/O service
- `src/utils/constants.py` — APP_VERSION and file extensions
- `src/views/ui/main_window.ui` — Qt Designer UI (XML; do not restructure, only change what's specified)

Run tests with: `pytest tests/ -v`
Run type checking with: `mypy src/`
Current branch: `testing`

---

## Task 1: Fix default tab (Clean tab should open first)

**Files:**
- Modify: `src/views/ui/main_window.ui` (line ~140)
- Test: `tests/integration/test_main_window.py`

The `tabWidget` in the `.ui` file has `currentIndex = 2`, which means the app opens on the Find/Replace tab instead of the Clean tab. Change it to `0`.

**Step 1: Write the failing test**

Add this class to `tests/integration/test_main_window.py` (use the existing `window` fixture):

```python
class TestDefaultTab:
    def test_opens_on_clean_tab(self, window):
        """Tab widget must default to index 0 (Clean tab), not 2 (Find/Replace)."""
        from PySide6.QtWidgets import QTabWidget
        tab = window.ui.findChild(QTabWidget, "tabWidget")
        assert tab is not None
        assert tab.currentIndex() == 0
```

**Step 2: Run test to verify it fails**

```bash
pytest tests/integration/test_main_window.py::TestDefaultTab::test_opens_on_clean_tab -v
```

Expected: `FAILED — AssertionError: assert 2 == 0`

**Step 3: Fix the .ui file**

In `src/views/ui/main_window.ui`, find these lines (around line 139-141):

```xml
                 <property name="currentIndex">
                  <number>2</number>
                 </property>
```

Change `<number>2</number>` to `<number>0</number>`.

**Step 4: Run test to verify it passes**

```bash
pytest tests/integration/test_main_window.py::TestDefaultTab -v
```

Expected: `PASSED`

**Step 5: Run full suite**

```bash
pytest tests/ -v
```

Expected: all existing tests still pass.

**Step 6: Commit**

```bash
git add src/views/ui/main_window.ui tests/integration/test_main_window.py
git commit -m "fix: open on Clean tab (index 0) instead of Find/Replace (index 2)"
```

---

## Task 2: Add keyboard shortcuts Ctrl+F, Ctrl+H, F3

**Files:**
- Modify: `src/views/main_window.py`
- Test: `tests/integration/test_main_window.py`

**Context:** Ctrl+S, Ctrl+O, Ctrl+Shift+S, Ctrl+Q are already wired via menu action shortcuts in the `.ui` file. The three missing shortcuts (Ctrl+F, Ctrl+H, F3) need `QShortcut` objects created programmatically in `_connect_signals`.

**Step 1: Write the failing tests**

Add this class to `tests/integration/test_main_window.py`:

```python
class TestKeyboardShortcuts:
    def test_ctrl_f_focuses_find_edit(self, window, qtbot):
        """Ctrl+F moves keyboard focus to the find line edit."""
        from PySide6.QtCore import Qt
        window.ui.show()
        qtbot.keyClick(window.ui, Qt.Key.Key_F, Qt.KeyboardModifier.ControlModifier)
        qtbot.wait(10)
        assert window._find_edit.hasFocus()

    def test_ctrl_h_focuses_replace_edit(self, window, qtbot):
        """Ctrl+H moves keyboard focus to the replace line edit."""
        from PySide6.QtCore import Qt
        window.ui.show()
        qtbot.keyClick(window.ui, Qt.Key.Key_H, Qt.KeyboardModifier.ControlModifier)
        qtbot.wait(10)
        assert window._replace_edit.hasFocus()

    def test_f3_triggers_find_next(self, window, qtbot):
        """F3 finds the next occurrence of the current search term."""
        from PySide6.QtCore import Qt
        window._plain_text_edit.setPlainText("hello world hello")
        window._find_edit.setText("hello")
        # First find
        window._on_find_clicked()
        assert window._plain_text_edit.textCursor().selectedText() == "hello"
        pos_after_first = window._plain_text_edit.textCursor().position()
        # F3 should advance to next
        qtbot.keyClick(window.ui, Qt.Key.Key_F3)
        qtbot.wait(10)
        assert window._plain_text_edit.textCursor().selectedText() == "hello"
        pos_after_second = window._plain_text_edit.textCursor().position()
        assert pos_after_second > pos_after_first
```

**Step 2: Run tests to verify they fail**

```bash
pytest tests/integration/test_main_window.py::TestKeyboardShortcuts -v
```

Expected: all three `FAILED` (shortcuts not wired yet).

**Step 3: Add imports and shortcuts in main_window.py**

In `src/views/main_window.py`, update the `PySide6.QtGui` import line (currently `from PySide6.QtGui import QAction`) to:

```python
from PySide6.QtGui import QAction, QKeySequence, QShortcut
```

At the end of `_connect_signals` in `MainWindow`, add:

```python
        # Keyboard shortcuts not in the .ui file (Ctrl+S/O/Q/Shift+S are already
        # wired via QAction shortcuts in main_window.ui)
        QShortcut(QKeySequence("Ctrl+F"), self.ui).activated.connect(
            self._find_edit.setFocus
        )
        QShortcut(QKeySequence("Ctrl+H"), self.ui).activated.connect(
            self._replace_edit.setFocus
        )
        QShortcut(QKeySequence("F3"), self.ui).activated.connect(
            self._on_find_clicked
        )
```

**Step 4: Run tests to verify they pass**

```bash
pytest tests/integration/test_main_window.py::TestKeyboardShortcuts -v
```

Expected: all three `PASSED`.

**Step 5: Run full suite and type check**

```bash
pytest tests/ -v
mypy src/
```

Expected: all tests pass, mypy 0 errors.

**Step 6: Commit**

```bash
git add src/views/main_window.py tests/integration/test_main_window.py
git commit -m "feat: add Ctrl+F, Ctrl+H, F3 keyboard shortcuts"
```

---

## Task 3: Normalize "ascii" encoding detection to "utf-8"

**Files:**
- Modify: `src/services/file_service.py`
- Test: `tests/unit/test_file_service.py`

**Context:** `chardet` correctly returns `"ascii"` for pure-ASCII files (ASCII is a valid subset of UTF-8). But showing "ascii" in the UI is confusing — the file is valid UTF-8 and will be saved as UTF-8. Normalize in `_detect_encoding` so the document always uses canonical encoding names. This fixes the live test encoding check and the UI label.

**Step 1: Write the failing test**

Add this test to `tests/unit/test_file_service.py`, inside the `TestDetectEncoding` class (or a new class if one doesn't exist):

```python
class TestDetectEncodingNormalization:
    def test_ascii_content_returns_utf8(self):
        """Pure-ASCII bytes must be labelled utf-8, not ascii.

        chardet correctly identifies ASCII bytes as 'ascii'. We normalize to
        'utf-8' because ASCII is a proper subset of UTF-8 and saving as utf-8
        is always safe for ASCII content.
        """
        from src.services.file_service import _detect_encoding
        raw = b"hello world"  # pure ASCII
        assert _detect_encoding(raw) == "utf-8"

    def test_non_ascii_utf8_content_returns_utf8(self, tmp_path):
        """Non-ASCII UTF-8 bytes (é, ñ) must return utf-8."""
        from src.services.file_service import _detect_encoding
        raw = "café résumé naïve".encode("utf-8")
        assert _detect_encoding(raw) == "utf-8"
```

**Step 2: Run tests to verify they fail**

```bash
pytest tests/unit/test_file_service.py::TestDetectEncodingNormalization -v
```

Expected: `test_ascii_content_returns_utf8 FAILED` (returns "ascii", not "utf-8").

**Step 3: Fix _detect_encoding in file_service.py**

In `src/services/file_service.py`, update `_detect_encoding`:

```python
def _detect_encoding(raw: bytes) -> str:
    """Return the most likely encoding for raw bytes.

    Module-level so it can be tested without instantiating FileService.
    Falls back to utf-8 if chardet is unavailable or confidence is too low.
    Normalizes 'ascii' to 'utf-8' because ASCII is a proper subset of UTF-8
    and saving as utf-8 is always safe for ASCII content.
    """
    try:
        import chardet  # optional dependency

        result = chardet.detect(raw)
        if result["encoding"] and result["confidence"] >= _ENCODING_MIN_CONFIDENCE:
            detected = result["encoding"].lower()
            # ASCII is a valid subset of UTF-8; normalize to avoid confusing the UI.
            return "utf-8" if detected == "ascii" else result["encoding"]
    except ImportError:
        logger.debug("chardet not installed; defaulting to utf-8")
    return _ENCODING_FALLBACK
```

**Step 4: Run tests to verify they pass**

```bash
pytest tests/unit/test_file_service.py::TestDetectEncodingNormalization -v
```

Expected: both `PASSED`.

**Step 5: Run full suite**

```bash
pytest tests/ -v
```

Expected: all tests pass. In particular, the integration tests for encoding label now work with pure-ASCII files too.

**Step 6: Commit**

```bash
git add src/services/file_service.py tests/unit/test_file_service.py
git commit -m "fix: normalize 'ascii' encoding to 'utf-8' (ASCII is valid UTF-8)"
```

---

## Task 4: Implement encoding conversion button (F-001)

**Files:**
- Modify: `src/viewmodels/main_viewmodel.py`
- Modify: `src/views/main_window.py`
- Test: `tests/unit/test_main_viewmodel.py`
- Test: `tests/integration/test_main_window.py`

**Context:** The Convert button currently shows "coming soon". The real behavior: take the current editor content, save the file as UTF-8, update the encoding label. Since we decode all files to Python `str` on load, conversion is simply re-saving with a new encoding. No new service method needed — `save_file` already accepts any encoding via `TextDocument`.

**Step 1: Write ViewModel unit tests**

Add this class to `tests/unit/test_main_viewmodel.py` (use the existing `vm`, `mock_file_svc`, `mock_text_svc` fixtures):

```python
class TestConvertToUtf8:
    def test_saves_file_with_utf8_encoding(self, vm, mock_file_svc, qtbot):
        """convert_to_utf8 must call save_file with encoding='utf-8'."""
        from src.models.text_document import TextDocument
        mock_file_svc.open_file.return_value = TextDocument(
            filepath="/tmp/latin.txt", content="caf\u00e9", encoding="ISO-8859-1"
        )
        vm.load_file("/tmp/latin.txt")
        vm.convert_to_utf8("café")
        saved_doc = mock_file_svc.save_file.call_args[0][0]
        assert saved_doc.encoding == "utf-8"
        assert saved_doc.content == "café"

    def test_emits_encoding_detected_utf8(self, vm, mock_file_svc, qtbot):
        """convert_to_utf8 must emit encoding_detected('utf-8')."""
        from src.models.text_document import TextDocument
        mock_file_svc.open_file.return_value = TextDocument(
            filepath="/tmp/latin.txt", content="caf\u00e9", encoding="ISO-8859-1"
        )
        vm.load_file("/tmp/latin.txt")
        with qtbot.waitSignal(vm.encoding_detected, timeout=1000) as blocker:
            vm.convert_to_utf8("café")
        assert blocker.args[0] == "utf-8"

    def test_emits_file_saved(self, vm, mock_file_svc, qtbot):
        """convert_to_utf8 must emit file_saved after a successful save."""
        from src.models.text_document import TextDocument
        mock_file_svc.open_file.return_value = TextDocument(
            filepath="/tmp/latin.txt", content="caf\u00e9", encoding="ISO-8859-1"
        )
        vm.load_file("/tmp/latin.txt")
        with qtbot.waitSignal(vm.file_saved, timeout=1000) as blocker:
            vm.convert_to_utf8("café")
        assert blocker.args[0] == "/tmp/latin.txt"

    def test_no_op_when_already_utf8(self, vm, mock_file_svc, qtbot):
        """convert_to_utf8 must not save when encoding is already utf-8."""
        from src.models.text_document import TextDocument
        mock_file_svc.open_file.return_value = TextDocument(
            filepath="/tmp/utf8.txt", content="hello", encoding="utf-8"
        )
        vm.load_file("/tmp/utf8.txt")
        vm.convert_to_utf8("hello")
        mock_file_svc.save_file.assert_not_called()

    def test_no_op_when_no_document(self, vm, qtbot):
        """convert_to_utf8 with no loaded document must be silent."""
        vm.convert_to_utf8("some text")  # must not raise

    def test_emits_error_on_save_failure(self, vm, mock_file_svc, qtbot):
        """convert_to_utf8 must emit error_occurred when save_file raises."""
        from src.models.text_document import TextDocument
        mock_file_svc.open_file.return_value = TextDocument(
            filepath="/tmp/latin.txt", content="caf\u00e9", encoding="ISO-8859-1"
        )
        vm.load_file("/tmp/latin.txt")
        mock_file_svc.save_file.side_effect = PermissionError("read-only")
        with qtbot.waitSignal(vm.error_occurred, timeout=1000) as blocker:
            vm.convert_to_utf8("café")
        assert "Cannot convert" in blocker.args[0]
```

**Step 2: Run tests to verify they fail**

```bash
pytest tests/unit/test_main_viewmodel.py::TestConvertToUtf8 -v
```

Expected: all `FAILED` with `AttributeError: 'MainViewModel' object has no attribute 'convert_to_utf8'`.

**Step 3: Add convert_to_utf8 to MainViewModel**

In `src/viewmodels/main_viewmodel.py`, add this method after `replace_all`:

```python
    @Slot(str)
    def convert_to_utf8(self, current_text: str) -> None:
        """Re-save the current document in UTF-8 encoding.

        Args:
            current_text: Live editor text from the View. Used as the content
                to save (preserves unsaved edits).

        No-op when no document is loaded or the file is already UTF-8.
        """
        if self._current_document is None:
            self.status_changed.emit("No document loaded")
            return
        current_encoding = self._current_document.encoding.lower().replace("-", "")
        if current_encoding in ("utf8",):
            self.status_changed.emit("File is already UTF-8")
            return
        doc = TextDocument(
            filepath=self._current_document.filepath,
            content=current_text,
            encoding="utf-8",
        )
        try:
            self._file_service.save_file(doc)
            self._current_document = doc
            self.encoding_detected.emit("utf-8")
            self.file_saved.emit(doc.filepath)
            self.status_changed.emit(f"Converted to UTF-8: {doc.filepath}")
        except (ValueError, PermissionError, OSError) as e:
            msg = f"Cannot convert file: {e}"
            logger.error(msg)
            self.error_occurred.emit(msg)
```

**Step 4: Run ViewModel tests to verify they pass**

```bash
pytest tests/unit/test_main_viewmodel.py::TestConvertToUtf8 -v
```

Expected: all `PASSED`.

**Step 5: Write the View integration test**

Add this class to `tests/integration/test_main_window.py`:

```python
class TestConvertEncodingHandler:
    def test_convert_button_calls_viewmodel(self, window, qtbot):
        """Clicking the Convert button must call viewmodel.convert_to_utf8."""
        from unittest.mock import patch
        window._plain_text_edit.setPlainText("hello")
        with patch.object(window._viewmodel, "convert_to_utf8") as mock_convert:
            window._convert_button.click()
        mock_convert.assert_called_once_with("hello")
```

**Step 6: Run the View test to verify it fails**

```bash
pytest tests/integration/test_main_window.py::TestConvertEncodingHandler -v
```

Expected: `FAILED` (button still shows "coming soon").

**Step 7: Wire the button in main_window.py**

In `src/views/main_window.py`, inside `_connect_signals`, replace:

```python
        # Encoding convert is stubbed for v1
        self._convert_button.clicked.connect(
            lambda: self.ui.statusBar().showMessage("Encoding conversion — coming soon")
        )
```

with:

```python
        # Encoding conversion: pass live editor text so unsaved edits are preserved
        self._convert_button.clicked.connect(
            lambda: self._viewmodel.convert_to_utf8(self._plain_text_edit.toPlainText())
        )
```

**Step 8: Run all tests and type check**

```bash
pytest tests/ -v
mypy src/
```

Expected: all pass, 0 mypy errors.

**Step 9: Commit**

```bash
git add src/viewmodels/main_viewmodel.py src/views/main_window.py \
        tests/unit/test_main_viewmodel.py tests/integration/test_main_window.py
git commit -m "feat: implement encoding conversion to UTF-8 (F-001)"
```

---

## Task 5: Add cursor position to status bar

**Files:**
- Modify: `src/views/main_window.py`
- Test: `tests/integration/test_main_window.py`

**Context:** `QStatusBar.addPermanentWidget()` places a widget on the right side of the status bar. It is never overwritten by `showMessage()`, making it perfect for live cursor position. Connect `QPlainTextEdit.cursorPositionChanged` to update it.

**Step 1: Write the failing tests**

Add this class to `tests/integration/test_main_window.py`:

```python
class TestStatusBarCursorPosition:
    def test_cursor_label_exists(self, window):
        """A permanent cursor label must be visible in the status bar."""
        assert hasattr(window, "_cursor_label")
        assert window._cursor_label.text() != ""

    def test_cursor_label_shows_line_and_col(self, window, qtbot):
        """Moving the cursor must update the cursor label."""
        window._plain_text_edit.setPlainText("first line\nsecond line")
        # Move cursor to start of second line (position 11)
        cursor = window._plain_text_edit.textCursor()
        cursor.setPosition(11)
        window._plain_text_edit.setTextCursor(cursor)
        qtbot.wait(10)
        label_text = window._cursor_label.text()
        assert "Ln 2" in label_text
        assert "Col 1" in label_text

    def test_cursor_label_shows_char_count(self, window, qtbot):
        """The cursor label must include the document character count."""
        window._plain_text_edit.setPlainText("hello")
        qtbot.wait(10)
        assert "5" in window._cursor_label.text()
```

**Step 2: Run tests to verify they fail**

```bash
pytest tests/integration/test_main_window.py::TestStatusBarCursorPosition -v
```

Expected: all `FAILED` (no `_cursor_label` attribute yet).

**Step 3: Add QLabel to imports and cursor label to MainWindow**

In `src/views/main_window.py`, the `QLabel` import is already present (used for `_encoding_label`). No import change needed.

Add `QSettings` import: in `from PySide6.QtCore import QDir, QFile, QModelIndex`, add `QSettings`:

```python
from PySide6.QtCore import QDir, QFile, QModelIndex, QSettings
```

At the end of `_load_ui`, after all `_require()` calls, add:

```python
        # Permanent status bar label — lives on the right, never overwritten by showMessage()
        self._cursor_label = QLabel("Ln 1, Col 1 | 0 chars")
        self.ui.statusBar().addPermanentWidget(self._cursor_label)
```

At the end of `_connect_signals`, add:

```python
        # Cursor position: update permanent label on every cursor move
        self._plain_text_edit.cursorPositionChanged.connect(self._update_cursor_label)
```

Add this new method after `_update_title`:

```python
    def _update_cursor_label(self) -> None:
        """Update the permanent cursor position label in the status bar."""
        cursor = self._plain_text_edit.textCursor()
        line = cursor.blockNumber() + 1
        col = cursor.columnNumber() + 1
        chars = len(self._plain_text_edit.toPlainText())
        self._cursor_label.setText(f"Ln {line}, Col {col} | {chars:,} chars")
```

**Step 4: Run tests to verify they pass**

```bash
pytest tests/integration/test_main_window.py::TestStatusBarCursorPosition -v
```

Expected: all `PASSED`.

**Step 5: Run full suite and type check**

```bash
pytest tests/ -v
mypy src/
```

Expected: all pass, 0 mypy errors.

**Step 6: Commit**

```bash
git add src/views/main_window.py tests/integration/test_main_window.py
git commit -m "feat: show cursor position and char count in status bar"
```

---

## Task 6: Implement Save As

**Files:**
- Modify: `src/views/main_window.py`
- Test: `tests/integration/test_main_window.py`

**Context:** `actionSave_as` is already wired to a "coming soon" lambda. Replace it with a proper handler that opens `QFileDialog.getSaveFileName`, sets the filename field, and delegates to the existing `_on_save_clicked`.

**Step 1: Write the failing tests**

Add this class to `tests/integration/test_main_window.py`:

```python
class TestActionSaveAsHandler:
    def test_chosen_path_is_saved(self, window, tmp_path, monkeypatch, qtbot):
        """getSaveFileName returns path → file saved to that path."""
        out = tmp_path / "renamed.txt"
        monkeypatch.setattr(
            "src.views.main_window.QFileDialog.getSaveFileName",
            lambda *a, **kw: (str(out), ""),
        )
        window._plain_text_edit.setPlainText("save-as content")
        with qtbot.waitSignal(window._viewmodel.file_saved, timeout=2000):
            window._on_action_save_as()
        assert out.read_text(encoding="utf-8") == "save-as content"
        assert window._file_name_edit.text() == str(out)

    def test_cancelled_dialog_is_no_op(self, window, monkeypatch):
        """getSaveFileName returns '' → nothing saved."""
        monkeypatch.setattr(
            "src.views.main_window.QFileDialog.getSaveFileName",
            lambda *a, **kw: ("", ""),
        )
        emitted: list = []
        window._viewmodel.file_saved.connect(emitted.append)
        window._on_action_save_as()
        assert emitted == []
```

**Step 2: Run tests to verify they fail**

```bash
pytest tests/integration/test_main_window.py::TestActionSaveAsHandler -v
```

Expected: `FAILED` with `AttributeError: 'MainWindow' object has no attribute '_on_action_save_as'`.

**Step 3: Add the handler in main_window.py**

In `src/views/main_window.py`, inside `_connect_signals`, replace:

```python
        self._action_save_as.triggered.connect(
            lambda: self.ui.statusBar().showMessage("Save As — coming soon")
        )
```

with:

```python
        self._action_save_as.triggered.connect(self._on_action_save_as)
```

Add this method after `_on_action_open`:

```python
    def _on_action_save_as(self) -> None:
        """Open a Save As dialog; save to the chosen path if confirmed."""
        _glob = " ".join(TEXT_FILE_EXTENSIONS)
        initial = self._file_name_edit.text() or QDir.homePath()
        path, _ = QFileDialog.getSaveFileName(
            self.ui,
            "Save As",
            initial,
            f"Text Files ({_glob});;All Files (*)",
        )
        if path:
            self._file_name_edit.setText(path)
            self._on_save_clicked()
```

**Step 4: Run tests to verify they pass**

```bash
pytest tests/integration/test_main_window.py::TestActionSaveAsHandler -v
```

Expected: both `PASSED`.

**Step 5: Run full suite and type check**

```bash
pytest tests/ -v
mypy src/
```

Expected: all pass, 0 mypy errors.

**Step 6: Commit**

```bash
git add src/views/main_window.py tests/integration/test_main_window.py
git commit -m "feat: implement Save As (was stubbed)"
```

---

## Task 7: Config persistence (window geometry + splitter positions)

**Files:**
- Modify: `src/views/main_window.py`
- Test: `tests/integration/test_main_window.py`

**Context:** Use `QSettings("TextTools", "TextTools")` — on Linux this writes to `~/.config/TextTools/TextTools.conf`. Store window geometry and both splitter states. Load on startup, save when the application quits. The `MainWindow` class is a plain Python controller (not a QMainWindow subclass), so save on `QApplication.aboutToQuit` rather than `closeEvent`.

`QSplitter` must be imported from `PySide6.QtWidgets`. The splitter names in the `.ui` file are `mainSplitter` and `leftPanelSplitter`.

**Step 1: Write the failing tests**

Add this class to `tests/integration/test_main_window.py`:

```python
class TestConfigPersistence:
    def test_save_settings_writes_geometry(self, window, qtbot):
        """_save_settings must write window/geometry to QSettings."""
        from PySide6.QtCore import QSettings
        # Clear any existing settings
        s = QSettings("TextTools", "TextTools")
        s.remove("window/geometry")
        window.ui.show()
        window._save_settings()
        s2 = QSettings("TextTools", "TextTools")
        assert s2.value("window/geometry") is not None

    def test_load_settings_does_not_raise_when_empty(self, window):
        """_load_settings must not raise when no settings have been saved."""
        from PySide6.QtCore import QSettings
        QSettings("TextTools", "TextTools").clear()
        window._load_settings()  # must not raise

    def test_save_and_restore_geometry(self, window, qtbot):
        """Geometry saved by _save_settings is restored by _load_settings."""
        from PySide6.QtCore import QSettings
        window.ui.show()
        window.ui.resize(700, 600)
        qtbot.wait(10)
        window._save_settings()
        # Change size
        window.ui.resize(300, 300)
        qtbot.wait(10)
        window._load_settings()
        qtbot.wait(10)
        # After restore the size should match what was saved
        size = window.ui.size()
        assert size.width() == 700
        assert size.height() == 600
```

**Step 2: Run tests to verify they fail**

```bash
pytest tests/integration/test_main_window.py::TestConfigPersistence -v
```

Expected: all `FAILED` (no `_save_settings` / `_load_settings` attributes yet).

**Step 3: Add QSplitter and QSettings imports**

In `src/views/main_window.py`:

Update `from PySide6.QtCore import QDir, QFile, QModelIndex, QSettings` (QSettings was added in Task 5 — skip if already done).

Update the `QWidgets` import block to include `QSplitter`:

```python
from PySide6.QtWidgets import (
    QApplication,
    QCheckBox,
    QFileDialog,
    QFileSystemModel,
    QLabel,
    QLineEdit,
    QMainWindow,
    QMessageBox,
    QPlainTextEdit,
    QPushButton,
    QSplitter,
    QTreeView,
)
```

**Step 4: Add splitter references in _load_ui**

At the end of `_load_ui` (before or after the `_cursor_label` block added in Task 5), add:

```python
        self._main_splitter = _require(
            self.ui.findChild(QSplitter, "mainSplitter"), "mainSplitter"
        )
        self._left_splitter = _require(
            self.ui.findChild(QSplitter, "leftPanelSplitter"), "leftPanelSplitter"
        )
```

**Step 5: Add _load_settings and _save_settings methods**

Add these two methods to `MainWindow` (after `_update_cursor_label`):

```python
    def _load_settings(self) -> None:
        """Restore window geometry and splitter positions from QSettings.

        Called at startup. Silent no-op when no settings exist yet
        (first launch or settings cleared).
        """
        settings = QSettings("TextTools", "TextTools")
        if geometry := settings.value("window/geometry"):
            self.ui.restoreGeometry(geometry)
        if main_state := settings.value("splitter/main"):
            self._main_splitter.restoreState(main_state)
        if left_state := settings.value("splitter/left"):
            self._left_splitter.restoreState(left_state)

    def _save_settings(self) -> None:
        """Save window geometry and splitter positions to QSettings.

        Called on application quit via aboutToQuit signal.
        """
        settings = QSettings("TextTools", "TextTools")
        settings.setValue("window/geometry", self.ui.saveGeometry())
        settings.setValue("splitter/main", self._main_splitter.saveState())
        settings.setValue("splitter/left", self._left_splitter.saveState())
```

**Step 6: Wire settings in __init__**

In `MainWindow.__init__`, after the `self._connect_signals()` call, add:

```python
        self._load_settings()
        app = QApplication.instance()
        if app is not None:
            app.aboutToQuit.connect(self._save_settings)
```

**Step 7: Run tests to verify they pass**

```bash
pytest tests/integration/test_main_window.py::TestConfigPersistence -v
```

Expected: all `PASSED`.

**Step 8: Run full suite and type check**

```bash
pytest tests/ -v
mypy src/
```

Expected: all pass, 0 mypy errors.

**Step 9: Commit**

```bash
git add src/views/main_window.py tests/integration/test_main_window.py
git commit -m "feat: persist window geometry and splitter positions via QSettings"
```

---

## Task 8: Bump version to 0.3.0

**Files:**
- Modify: `src/utils/constants.py`
- Modify: `CHANGELOG.md`
- Test: `tests/unit/test_constants.py`

**Step 1: Check the existing constants test**

```bash
grep -n "APP_VERSION" tests/unit/test_constants.py
```

If there is a test asserting the current version string, update it to `"0.3.0"`.

**Step 2: Update constants.py**

In `src/utils/constants.py`, change:

```python
APP_VERSION = "0.2.0"
```

to:

```python
APP_VERSION = "0.3.0"
```

**Step 3: Update CHANGELOG.md**

Add a new section at the top of `CHANGELOG.md`:

```markdown
## [0.3.0] — 2026-02-21

### Added
- Default tab is now Clean (was Find/Replace)
- Keyboard shortcuts: Ctrl+F (find), Ctrl+H (replace), F3 (find next)
- Encoding conversion button (F-001): re-saves file as UTF-8
- Cursor position and character count in status bar
- Save As (was stubbed)
- Window geometry and splitter positions persist across sessions (QSettings)

### Fixed
- Encoding label now shows "utf-8" for ASCII files (ASCII is a subset of UTF-8)
```

**Step 4: Run full suite**

```bash
pytest tests/ -v
```

Expected: all tests pass.

**Step 5: Commit**

```bash
git add src/utils/constants.py CHANGELOG.md tests/unit/test_constants.py
git commit -m "chore: bump version to 0.3.0"
```

---

## Verification

After all tasks are complete, run the offscreen smoke test to verify end-to-end:

```bash
uv run python scripts/live_test.py
```

Expected output: `All 15 checks passed.`

Then run the full test suite one final time:

```bash
pytest tests/ -v --tb=short
```

Expected: all tests pass (count will be higher than 113 after new tests are added).
